<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        //명령형 스타일
        let sum = 0;
        for(let i = 1; i<=5; i++){
            const squared = i*i;
            sum += squared;
        }

        console.log(sum);

        //어떻게 할지에 초점이 맞추어져있는 코드이다.
        //변수 sum을 계속 바꾸면서 결과를 만든다.

        //함수형 스타일
        const numbers = [1,2,3,4,5];

        const sumOfSquares = numbers
            .map(n => n * n) //각 숫자를 제곱한 새 배열을 생성
            .reduce((acc,n) => acc+n,0); //모두 더하기

        console.log(sumOfSquares)

        //무엇을 할지에 초점이 맞춰진 코드이다.
        //numbers배열은 건드리지 않고, 새 값을 만들어서 넘겨준다.

        //순수함수
        //같은 입력을 넣으면 항상 같은 출력이 나오는 함수
        //함수 밖의 상태를 변경하지 않고, 함수 밖의 상태에 의존하지 않는다.

        function add(a,b){
            return a + b;
        }

        //같은 값을 넣으면 항상 같은 값이 나온다.

        let count = 0;
        function increase(){
            count++;
            return count;
        }
        
        console.log(increase());//1
        console.log(increase());//2

        //테스트하기가 어렵고, 버그 추적이 힘들다

        //실무에서는 비즈니스 로직은 최대한 순수함수로 분리하고
        //입출력, API호출, DOM조작같은 부분만 "껍데기"부분에서 처리하는 식으로 설계한다.

        //불변성
        //함수형 프로그래밍에서는 원본 데이터를 직접 바꾸지 않고, 복사본이나
        //새 값을 만들어서 사용하는 것을 선호한다.

        const numbers2 = [1,2,3];

        numbers2.push(4); //원본 배열에 4를 추가
        console.log(numbers2);//[1,2,3,4]

        //이렇게 해도 동작에는 문제가 없지만, 프로젝트가 커지면
        //어디서 배열이 바뀐건지 추적하기가 어려워진다.

        const numbers3 = [1,2,3];

        const newNumbers = [...numbers3, 4];// 복사본에 새 값을 추가

        console.log(numbers3);
        console.log(newNumbers);

        const users = [
            {name:"kim", age : 20},
            {name:"Lee", age : 30},
        ]

        //나이만 +1을 한 새 배열을 만든다.
        const olderUsers = users.map(user => ({...user, age : user.age + 1}));
        console.log(users[0].age);
        console.log(olderUsers[0].age);

        //이 함수는 절대 외부 데이터를 건드리지 않는다 라고 믿고 사용할 수 있다.

        //배열에서 자주쓰는 함수형 메서드
        //map()
        //각 요소를 변환해서 새 배열을 만드는 메서드

        const person = [
            {id : 1, name: 'kim'},
            {id : 2, name : 'lee'},
        ]

        const options = person.map(person => ({
            label:person.name, 
            value:person.id,
        }));

        // [{label : "kim", value : 1}, {label:"lee", value:2}];
        console.log(options)

        //filter()
        //조건을 만족하는 요소만 골라서 새 배열을 만드는 메서드
        const products = [
            {name:"노트북",price:1500000, soldOut : false},
            {name:"마우스",price:20000, soldOut : true},
            {name:"키보드",price:150000, soldOut : false},
        ]

        //품절이 아닌 상품만 availableProducts에 넣기
        const availableProducts = products.filter(p => !p.soldOut);
        console.log(availableProducts)

        //reduce()
        //배열을 하나의 값으로 만드는 메서드
        const carts = [
            {name:"노트북",price:1500000, quantity:1},
            {name:"마우스",price:20000, quantity:2},
            {name:"키보드",price:150000, quantity:3},
        ];

        //카트에 들어있는 모든 상품의 총 합계 구하기
        const totalPrice = carts.reduce((acc, item) => acc + item.price * item.quantity,0);

        //숫자를 두배로 만들기
        const double = x => x * 2;
        //1을 더하는 함수
        const increment = x => x + 1;

        //2를 곱하고 1을 더하는 작업을 하고싶다면 두 함수를 합성해서 쓸 수 있다.
        const result = increment(double(5));

        //조금 더 일반적인 함수를 만들수도 있다.
        //함수들을 여러 개 받아서 -> 하나의 함수로 합쳐주는 고차 함수
        //...fns -> compose에 넘긴 모든 인자를 배열로 모아서 fns에 넣는다.
        //reduceRight -> 배열의 오른쪽에서 왼쪽 방향으로 순회하면서 값을
        //누적시키는 함수
        const compose = (...fns) => x => 
            fns.reduceRight((acc,fn) => fn(acc),x);

        const doubleThenIncrement = compose(increment,double);

        console.log(doubleThenIncrement(5));









    </script>
</body>
</html>