이벤트 버블링
안쪽에서 바깥쪽으로 전파

이벤트 캡처링
바깥쪽에서 안쪽으로 전파

이벤트 위임
자식요소가 너무 많아지게 되고, 자식요소마다 이벤트를 다 주게 되면 비효율적이다.

부모요소한테 이벤트를 위임을 하고, 실제 이벤트가 발생한 자식 요소에 이벤트 처리를 한다.

<ul>
    <li></li>
    <li></li>
    <li></li>
</ul>
1. 공통 부모를 선택
const list = document.querySelector("ul");

2. 부모에게 이벤트 핸들러를 등록
※발생한 이벤트에 관한 정보가 매개변수로 전달이 된다.
list.addEvenetListener("click", function(event){
	//여기에 분기 처리 로직을 작성
});

3. 어떤 자식이 클릭됐는지 확인
- event.target : 실제로 클릭된 가장 안쪽 요소
list.addEvenetListener("click", function(event){
    console.log("실제로 클릭된 것:", event.target);
});

4. 조건문 또는 closest()로 필요한 요소만 처리
list.addEvenetListener("click", function(event){
    const li = event.target.closest('li'); //가장 가까운li 찾기

    if(!li || !list.containse(li)){
        //li가 아니면(또는 ul 바깥이면) 무시
        return;
    }

    //이벤트 처리

});

ECMAScript : JavaScript의 공식 표준 이름이다.
- 우리가 사용하는 브라우저의(크롬) JS엔진이 ECMAScript 규격을 구현한것이다.
- 이 표준은 번호로 관리가 된다.
ES1,ES2,ES3... ES6
ES6 
let,const

스코프(Scope)
변수가 보이는 범위
- 어디까지 이 변수를 사용할 수 있는지 정해주는 규칙
1. 전역스코프(global)
2. 함수스코프(function)
3. 블록스코프(block)

호이스팅(Hoisting)
선언을 위로 끌어올려서 먼저 처리하는 자바스크립트 엔진의 작동 방식

코드를 위에서 아래로 읽는것 처럼 보이지만, 내부적으로 두 단계로 처리한다.

1. 준비단계
- 변수 선언, 함수 선언만 먼저 쭉 훑어서 등록한다.
2. 실행단계
- 실제로 한 줄 씩 실행한다.

호이스팅에 대해서 알아야 하는 이유
1. 디버깅할 때
선언 안했는데 "undefined"뭐지?같은 상황을 이해할 수 있다.
2. 리팩토링 할 때
선언식 -> 표현식을 바꿀 때
var -> let,const로 바꿀 때 
어느 부분에서 에러가 날지 예상

화살표 함수

기본적인 함수의 선언
function 함수명(매개변수){
    return 반환값;
}

함수명(인자)

함수 표현식

const add = function (a,b){
    return a + b;
}

화살표 함수의 기본 문법

const add = (a,b) => {
    return a + b;
}

(매개변수) => {함수 본문}

1. 매개변수가 1개면 소괄호를 생략할 수 있다.

2.명령이 return 한줄이면 return 키워드와 {}를 같이 생략할 수 있다.


템플릿 리터럴
'', "" 가 아니라 백틱 ``을 사용한다.
${}안에 변수를 넣거나, 간단한 연산/함수 호출도 가능하다.

디스트럭처링(분해 할당)

주의해야 할 점
1. 객체 분해할당을 할 때는 "키 이름"이 정확히 맞아야 한다.
2. 너무 깊게 중첩해서 한 줄에 따 쓰면 가독성이 떨어진다.
- 가볍게 1~2단계까지만 쓰고, 나머지는 변수로 나눠서 사용하는게 좋다.
3. 함수 인자에서 분해할당 + 기본값을 쓸 때는
function Fn({...}={}) 같이 전체 인자에도 기본값을 넣어주는 패턴을 사용하자!!

































